from src.instances import openAI_client,embedding_model
from src.exception import CustomException
from src.logger import logging
from src.workers.utils import get_embedding
from src.dependencies import os,json,sys,time,uuid,requests,TextLoader,QA_SUMMARISER_OPENAI_ASSISTANT_ID,ADMIN_ID_QA,COURSE_ID_QA,TOPIC_ID_QA
from src.workers.QA.instances import qa_summariser_thread,index_qa_base

def load_QA_data(file_url):
    """
    Function to classify the file as either a text or PDF file, download it from a given URL,
    and return the finalised QA as a string.

    Args:
        file_url (str): The URL of the file to be classified

    Returns:
        data : The text parseable JSON of the conversation
    """

    try:
        response = requests.get(file_url)
        response.raise_for_status()  

        responseContent = response.content
        data = responseContent.decode('UTF-8')

        return data
    except Exception as e:
        raise CustomException(e,sys)
    
            

def create_QAPair(conversation):
    """ 
    Function to generate a question-answer pair from a given conversation. The primary aim would be to push 
    a conversation to the QA summariser thread and run the thread for the assistant to generate a question-answer pair.

    Args:
        conversation (string): An JSON parsable string object of string key value pairs, where each key is the sender and each value is their message 
        from them.

    Returns:
        run : The run object from OpenAI Assistants (https://platform.openai.com/docs/api-reference/runs/object)
    """
    try:
        openAI_client.beta.threads.messages.create(
            thread_id=qa_summariser_thread.id,
            role="user",
            content= [{
                "type" : "text",
                "text" : conversation
            }]
        )
                
        run = openAI_client.beta.threads.runs.create(
            thread_id=qa_summariser_thread.id,
            assistant_id=QA_SUMMARISER_OPENAI_ASSISTANT_ID,
        )
        
        return run
        
    except Exception as e:
        raise CustomException(e,sys)

def get_QAPair(thread, run):
    """ 
    Function to get the Q&A pair generated by the assistant in the thread and run provided.

    Args:
        1. thread : The thread object from OpenAI Assistants (https://platform.openai.com/docs/api-reference/threads/object)
        2. run : The run object from OpenAI Assistants (https://platform.openai.com/docs/api-reference/runs/object)

    Returns:
        messages : The messages object from OpenAI Assistants (https://platform.openai.com/docs/api-reference/messages/object)
    """
    try:
        while True:
            run = openAI_client.beta.threads.runs.retrieve(
                thread_id=thread.id,
                run_id=run.id
            )
            if run.status == 'completed':
                messages = openAI_client.beta.threads.messages.list(
                    thread_id=thread.id
                )
                return messages
            elif run.status in ['failed', 'cancelled', 'expired']:
                raise Exception(f"Run ended with status: {run.status}")
            time.sleep(1)
    except Exception as e:
        raise CustomException(e,sys)
         
def get_QA(conversation,thread_id):
    """
        Function to get the Q&A pair generated given the conversation and prepare it as a dictionary, with conversation ID as the key (dummy id generated using uuid for now).
        
        Args:
            conversation : A dictionary containing the conversation between the user and the assistant
            
        Returns:
            QA : A dictionary containing the Q&A pair generated by the assistant
    """
    try : 
        QA = {}

        run = create_QAPair(conversation)
        messages = get_QAPair(qa_summariser_thread, run)
        
        if(messages):
            QA[thread_id] = messages.data[0].content[0].text.value
        else:
            QA[thread_id] = {"question" : "Not available", "answer" : "Not available"}
            raise CustomException("No Q&A pair generated by the assistant",sys)
            
        return QA
    except Exception as e:
        raise CustomException(e,sys)
    
def create_QA_vector(QA,ADMIN_ID,COURSE_ID,TOPIC_ID):
    """
        Function to convert the Q&A pair into pinecone records to upsert into our index
    
        Args:
            QA : A dictionary containing the conversation id, and the Q&A pair string as a parsable json generated by the assistant
            ADMIN_ID : The userID of the admin who created this document, used to store in metadata of record
            COURSE_ID : The courseID of the course the chunk is from, used to store in metadata of record
            TOPIC_ID : The topicID of the topic the chunk is from, used to store in metadata of record
            
        Returns:
            entry : A final pinecone record
    """
    try:
        entry = {}
        
        QA_ID = list(QA.keys())[0]
        QA_Pair = json.loads(QA[QA_ID])
        
        entry["id"] = f"{ADMIN_ID}_{COURSE_ID}_{TOPIC_ID}_{QA_ID}"
        
        question = QA_Pair["question"]
        answer = QA_Pair["answer"]
        text = "Question : " + question + "\nAnswer : " + answer
        
        entry["values"] = get_embedding(text)
        entry["metadata"] = {
            "ADMIN_ID" : ADMIN_ID,
            "COURSE_ID" : COURSE_ID,
            "TOPIC_ID" : TOPIC_ID,
            "QA_ID" : QA_ID,
            "question" : question,
            "answer" : answer
        }
            
        return entry
    
    except Exception as e:
        raise CustomException(e,sys)
    
    
def upsert_QA_vectors(vector):
    """
        Function to upsert the vector records into the index
    
        Args:
            vector : The collection of records as defined above
            
    """
    
    try:
        record_status = index_qa_base.upsert(
            vectors=[vector]
        )  
        
        upserted_count = record_status.get("upserted_count", len(vector))
        logging.info(f"Total records upserted successfully: {upserted_count}")
        
        return record_status
    
    except Exception as e:
        raise CustomException(e,sys)

def delete_QA_vectors(qa_id,ADMIN_ID,COURSE_ID,TOPIC_ID):
    """
        Function to delete vectors associated to a given document
    
        Args:
            qa_id : The id of the document, used to match prefix of records
            ADMIN_ID : The userID of the admin who created this document, used to store in metadata of record
            COURSE_ID : The courseID of the course the chunk is from, used to store in metadata of record
            TOPIC_ID : The topicID of the topic the chunk is from, used to store in metadata of record
    """
    
    try:
        res = index_qa_base.delete([ids for ids in index_qa_base.list(prefix = f"{ADMIN_ID}_{COURSE_ID}_{TOPIC_ID}_{qa_id}")])
        return res
    
    except Exception as e:
        raise CustomException(e,sys)